<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Don't Turn Off The Lights - WebXR Horror</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="importmap">
  {"imports": {"three": "https://unpkg.com/three@0.150.1/build/three.module.js"}}
  </script>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
    #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; display: flex; align-items: center; justify-content: center; }
    #start-button { width: 100%; height: 100%; font-size: 120px; background: #111; color: #f00; border: none; cursor: pointer; text-shadow: 0 0 20px #f00; }
    .webxr-hidden { display: none !important; }
  </style>
</head>
<body>
  <div id="overlay"><button id="start-button">ðŸ’€</button></div>
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'https://unpkg.com/three@0.150.1/examples/jsm/loaders/GLTFLoader.js';
    
    let camera, scene, renderer, xrSession, controllers = [];
    let lightSwitch, isLightOn = true, clickCount = 0, tension = 0, isToggling = false;
    let zombieModel = null, currentMonster = null, jumpScareActive = false;
    let nextScareThreshold = 3 + Math.random() * 4;
    const clock = new THREE.Clock();
    let gltfLoader = null;
    let occlusionPlane;
    // ## NEW: Sound effect variables ##
    let clickSound, zombieSound;
    
    // Monster management
    class Monster {
      constructor(scene, model, level) {
        this.group = model.clone();
        this.level = level;
        scene.add(this.group);
        this.speed = 0.002 + level * 0.001;
        this.startTime = clock.getElapsedTime();
        
        const scale = 0.5 + level * 0.05;
        this.group.scale.set(scale, scale, scale);
        
        this.group.traverse((child) => {
          if (child.isMesh) {
            child.material = child.material.clone();
            child.material.emissive = new THREE.Color(0x440000);
            child.material.emissiveIntensity = 0.3 + level * 0.1;
          }
        });
        
        const angle = Math.random() * Math.PI * 2;
        const dist = 0.4 + Math.random() * 0.3;
        this.group.position.set(
          Math.sin(angle) * dist,
          -0.5,
          -0.5 - Math.random() * 0.3
        );
        this.group.lookAt(0, 0, 0);
      }
      
      update() {
        const t = clock.getElapsedTime();
        this.group.position.z += this.speed;
        this.group.position.x += Math.sin(t * 4) * 0.001;
        this.group.position.y = -0.5 + Math.sin(t * 2) * 0.05;
        this.group.rotation.y = Math.sin(t * 3) * 0.1;
        const pulse = 1 + Math.sin(t * 10) * 0.05;
        this.group.scale.set(this.group.scale.x * pulse / this.group.scale.x, this.group.scale.y * pulse / this.group.scale.y, this.group.scale.z * pulse / this.group.scale.z);
      }
      
      destroy() {
        this.group.parent?.remove(this.group);
      }
    }
    
    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
      scene.add(camera);
      
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);
      
      // ## NEW: Pre-load audio files ##
      clickSound = new Audio('click.mp3');
      zombieSound = new Audio('zombie.mp3');
      clickSound.load();
      zombieSound.load();
      
      const occlusionGeometry = new THREE.PlaneGeometry(2, 2);
      const occlusionMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0 });
      occlusionPlane = new THREE.Mesh(occlusionGeometry, occlusionMaterial);
      occlusionPlane.position.z = -0.02;
      camera.add(occlusionPlane);
      
      gltfLoader = new GLTFLoader();
      loadZombieModel();
      
      const ambient = new THREE.AmbientLight(0x303030, 0.5);
      scene.add(ambient);
      const spot = new THREE.SpotLight(0xffa500, 0.3);
      spot.position.set(0, 2, 0);
      spot.castShadow = true;
      spot.angle = Math.PI / 4;
      spot.penumbra = 0.5;
      scene.add(spot);
      
      createLightSwitch();
      document.getElementById('start-button').addEventListener('click', startAR);
    }
    
    async function loadZombieModel() {
      try {
        const gltf = await gltfLoader.loadAsync('zombie.glb');
        zombieModel = gltf.scene;
        zombieModel.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });
        console.log('Zombie model loaded!');
      } catch (error) {
        console.warn('Failed to load zombie.glb, using fallback:', error);
        const geometry = new THREE.BoxGeometry(0.3, 0.6, 0.3);
        const material = new THREE.MeshPhongMaterial({ color: 0x220000, emissive: 0x440000, emissiveIntensity: 0.3 });
        zombieModel = new THREE.Mesh(geometry, material);
      }
    }
    
    function createLightSwitch() {
      const group = new THREE.Group();
      const plateGeo = new THREE.BoxGeometry(0.14, 0.22, 0.03);
      const plateMat = new THREE.MeshPhongMaterial({ color: 0xf5f5dc, roughness: 0.7, metalness: 0.1 });
      const plate = new THREE.Mesh(plateGeo, plateMat);
      plate.castShadow = true;
      plate.receiveShadow = true;
      group.add(plate);
      
      const screwGeo = new THREE.CylinderGeometry(0.004, 0.004, 0.005);
      const screwMat = new THREE.MeshPhongMaterial({ color: 0x888877, metalness: 0.8 });
      const screwTop = new THREE.Mesh(screwGeo, screwMat);
      screwTop.rotation.x = Math.PI / 2;
      screwTop.position.set(0, 0.09, 0.016);
      group.add(screwTop);
      const screwBottom = screwTop.clone();
      screwBottom.position.set(0, -0.09, 0.016);
      group.add(screwBottom);
      
      const switchBase = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.08, 0.025), new THREE.MeshPhongMaterial({ color: 0x333333 }));
      switchBase.position.z = 0.02;
      group.add(switchBase);
      
      const leverGeo = new THREE.BoxGeometry(0.025, 0.045, 0.015);
      const leverMat = new THREE.MeshPhongMaterial({ color: 0x222222, roughness: 0.3, metalness: 0.2 });
      const lever = new THREE.Mesh(leverGeo, leverMat);
      lever.position.set(0, 0.01, 0.035);
      lever.name = 'lever';
      lever.castShadow = true;
      group.add(lever);
      
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 256; canvas.height = 64;
      ctx.fillStyle = '#f5f5dc'; ctx.fillRect(0, 0, 256, 64);
      ctx.fillStyle = '#000'; ctx.font = 'bold 24px "Courier New", monospace';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText('LIGHTS', 128, 20);
      ctx.font = '16px "Courier New", monospace';
      ctx.fillText('DO NOT TOUCH', 128, 44);
      const labelTexture = new THREE.CanvasTexture(canvas);
      const labelMat = new THREE.MeshBasicMaterial({ map: labelTexture });
      const labelGeo = new THREE.PlaneGeometry(0.1, 0.025);
      const label = new THREE.Mesh(labelGeo, labelMat);
      label.position.set(0, -0.06, 0.016);
      group.add(label);
      
      group.position.set(0, 0, -0.5);
      group.rotation.x = -0.1;
      scene.add(group);
      lightSwitch = group;
    }
    
    async function startAR() {
      if (!navigator.xr) return alert('WebXR not supported');
      try {
        const session = await navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: document.body }
        });
        onSessionStarted(session);
      } catch (e) {
        console.error("Failed to start AR session", e);
      }
    }
    
    function onSessionStarted(session) {
      xrSession = session;
      document.getElementById('overlay').classList.add('webxr-hidden');
      renderer.xr.setReferenceSpaceType('local');
      renderer.xr.setSession(session);
      
      for (let i = 0; i < 2; i++) {
        const controller = renderer.xr.getController(i);
        controller.addEventListener('selectstart', onSelect);
        scene.add(controller);
        controllers.push(controller);
      }
      
      renderer.setAnimationLoop(render);
      session.addEventListener('end', () => {
        document.getElementById('overlay').classList.remove('webxr-hidden');
        renderer.setAnimationLoop(null);
      });
    }
    
    function onSelect(event) {
      if (isToggling || !lightSwitch) return;

      const controller = event.target;
      const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(controller.quaternion);
      const raycaster = new THREE.Raycaster(controller.position, direction);
      
      const intersects = raycaster.intersectObjects(lightSwitch.children, true);
      if (intersects.length > 0) {
        isToggling = true;
        toggleLight();
        setTimeout(() => { isToggling = false; }, 200);
      }
    }
    
    function toggleLight() {
      isLightOn = !isLightOn;
      clickCount++;
      tension = Math.min(clickCount / 10, 1);
      
      const lever = lightSwitch.getObjectByName('lever');
      
      if (isLightOn) {
        occlusionPlane.material.opacity = 0;
        lever.position.y = 0.01;
        lever.rotation.z = 0;
        
        if (currentMonster) {
          currentMonster.destroy();
          currentMonster = null;
          jumpScareActive = false;
          // ## NEW: Stop zombie sound when light is turned on ##
          zombieSound.pause();
        }
        playClickSound(); // No argument needed
      } else {
        occlusionPlane.material.opacity = 1;
        lever.position.y = -0.01;
        lever.rotation.z = -0.2;
        playClickSound(); // No argument needed
        
        if (clickCount > nextScareThreshold && !jumpScareActive && zombieModel) {
          const delay = 500 + Math.random() * (3000 - tension * 2000);
          setTimeout(() => {
            if (!isLightOn) spawnHorror();
          }, delay);
          nextScareThreshold = clickCount + 2 + Math.random() * (5 - tension * 3);
        }
      }
    }
    
    // ## FIX: Use custom audio file for click sound ##
    function playClickSound() {
      clickSound.currentTime = 0;
      clickSound.play().catch(e => console.error("Could not play click sound:", e));
    }
    
    function spawnHorror() {
      if (jumpScareActive || isLightOn || !zombieModel) return;
      
      jumpScareActive = true;
      const level = Math.floor(tension * 10) + 1;
      currentMonster = new Monster(scene, zombieModel, level);
      
      occlusionPlane.material.opacity = 0.5;
      setTimeout(() => {
        if (!isLightOn) occlusionPlane.material.opacity = 1;
      }, 100);
      
      // ## NEW: Play zombie sound ##
      playHorrorSound();
      zombieSound.currentTime = 0;
      zombieSound.play().catch(e => console.error("Could not play zombie sound:", e));
      
      if (xrSession && xrSession.inputSources) {
        for (const source of xrSession.inputSources) {
          if (source.gamepad && source.gamepad.hapticActuators) {
            source.gamepad.hapticActuators[0]?.pulse(1, 200);
          }
        }
      }
    }
    
    function playHorrorSound() {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.type = 'sawtooth';
      oscillator.frequency.setValueAtTime(120, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(40, audioContext.currentTime + 0.5);
      gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.5);
    }
    
    function render(time, frame) {
      // ## FIX: Remove the automatic despawn logic ##
      // The zombie will now only be destroyed when the player turns the lights on.
      if (currentMonster && !isLightOn) {
        currentMonster.update();
      }
      
      if (lightSwitch && currentMonster) {
        const dist = currentMonster ? Math.abs(currentMonster.group.position.z) : 1;
        const shake = dist < 0.5 ? (0.5 - dist) * 0.002 : 0;
        lightSwitch.position.x = Math.sin(time * 0.05) * shake;
      }
      
      renderer.render(scene, camera);
    }
    
    init();
  </script>
</body>
</html>
